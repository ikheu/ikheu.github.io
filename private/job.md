---
layout: post
title: 面试题
permalink: /job/
---
* content
{:toc}


## 数据结构与算法

### 跳表的实现
详见 redis skiplist

### 哈夫曼编码
- 一种压缩编码算法，在对文本进行编码时，考虑文本中每个字符出现的概率，对高概率的采用更小的编码。

### 无递归不使用额外空间遍历树


## 编程语言

### 垃圾回收

- 引用计数
- 标记清除
- 分代回收

## 计算机网络


### nginx 负载均衡算法

- 轮循（默认）
- 权重
- ip 哈希
- fair 根据响应时间来分配请求，第三方
- url hash 根据 url 来选择服务器 第三方

### 惊群效应

- nginx： worker 进程从 master 进程复制了监听描述符，而当相应事件到达时，多个进程被唤醒，只有一个进程能与它建立连接，而所有进程都会被继续等待
- 解决方法：只唤醒一个进程。增加锁

### apache 和 nginx 的区别

- apache 基于多线程
- nginx 基于事件驱动，master 进程， worker 进程


### http2.0


### 幂等

多次操作的作用是相同的。POST 不具有幂等行。


### wsgi

web 服务器网关接口，指服务器和 web 应用之间的接口协议。


### rest, soap, rpc

- rest：表现层状态转移。基于 HTTP 原则的设计理念。耦合性低，兼容性好，提高开发效率，不用关心接口实现细节，相对更规范，更标准，更通用，跨语言支持，性能不如 RPC 高。
- rpc: 远程方法调用，就是像调用本地方法一样调用远程方法。掩盖了网络请求的事实。


### csrf, xss, syn 泛洪，中间人攻击
- xss：跨站脚本(攻击)，恶意脚本被嵌入到网页中，访问时执行脚本，导致用户信息、cookie被窃取。
- csrf：跨站请求伪造，劫持已认证用户执行非本意操作。可以通过校验referer，增加token等方式防御。
- 中间人攻击：
- 

### 浏览器输入url后的整个过程

url解析 -> 构造 http 请求 -> DNS 解析 -> 协议栈发送 -> 协议栈接受 -> 服务器 web 程序处理 -> .(相反过程). -> 浏览器渲染，含有链接会继续请求


### keepalive

http的keepalive：一次 tcp 连接后进行多次请求与响应。

tcp的用来检测心跳。


### http 方法

- get，post 的区别

### 什么是https，提供了什么功能

http + ssl/tsl，属于应用层，位于传输层之上。提供以下安全功能：
- 完整性保护，防止中间人攻击。散列函数 + 鉴别密匙 = 报文鉴别码 (mac)
- 加密，防止。公开密匙加密（+对称密匙），对话密匙是对称加密，公匙用来加密对话密匙。
- 端点鉴别，防止伪装。通过数字签名。CA 证书中包含公匙信息。


### https 握手过程

涉及四次通信，就通信加密算法达成一致：
- 客户端发出请求，发送支持的加密算法和客户端随机数
- 服务器选择对称算法，公匙算法和mac算法，加上证书+服务器随机数
- 客户端验证证书，提取公匙，生成前主密匙（PMS），使用公匙加密前主密匙并发给服务器；发送整个握手报文的mac
- 客户端服务器两方根据 PMS + 随机数，计算出主密匙（MS），切片成两个会话加密密匙和两个mac密匙；发送整个握手报文的mac


### TCP 协议特点

TCP 是一个面向连接的可靠传输服务。
- 有握手挥手过程
- 顺序发送字节流，保证数据有序、无丢失。数据按照顺序分包。序号的确认应答，超时重传
- 流量控制：通过接受窗口大小来控制。
- 拥塞控制：慢启动，拥塞避免，快速恢复。通过控制拥塞窗口来实现。

### TCP 握手过程

- 客服端向服务器发送报文 SYN + 序列号 
- 服务器接受后，响应报文 ACK号 + SYN
- 客户端发送报文 ACK 号

握手时需要确认双方序列号，因此需要三次握手。


### TCP 挥手过程

- 客户端向服务器发送 FIN = 1 报文
- 服务器向客户端发送 ACK 号 报文
- 服务器向客户端发送 FIN = 1 报文
- 客户端向服务器发送 ACK 号 报文

主动关闭的一方在接受另一方的关闭报文后，进入 time_wait。套接字如果立刻释放，新建立的套接字使用同一个端口，那么重发的 FIN 会关闭新的套接字。time_wait 覆盖了报文丢弃前的存活时间。

挥手四次，是因为 TCP 是全双工的，关闭时两端需要独立关闭。

服务器端过多 close_wait：服务器收到 FIN，发送 ACK 后，进入 close_wait，过多会导致监听套接字过多，资源无法释放，影响通信。 解决方式：应用程序主动关闭；手动删除；调整过期时间。


### TCP 粘包

粘包指独立的包发送接收后粘成一起。是一个伪问题。TCP 是流协议，无法得知数据的含义以及完整性情况。需要应用层自己解决。

### UDP 协议特点

UDP 是一个无连接的不可靠的传输服务。相比TCP：
- 无需连接
- 不保证报文顺序
- 没有拥塞机制

### 如何实现一个相对可靠的 UDP

- 在应用层去模拟 TCP 的部分功能，有序发送，重传等。

## 数据库

### 一致性哈希
- 直接采用哈希求余的方式影响数据与节点的映射关系
- 哈希值呈环状分布，节点分布在环上，查找时，数据 key 的哈希值顺时针第一个遇到的节点
- 新增或删除节点时，影响相邻节点的数据命中，需要单独处理这部分数据，缓存场景下可以忽略
- 节点数太少时，节点变动对数据影响较大

### cap 理论

关于复制和分区的疑惑可以参考数据密集一书 p191，一个节点上有不同的分区，同一个分区在不同节点上有多个副本。一个节点是一个数据中心，一个分区是数据集的一部分，在一个节点中占一台机器。

- 一致性：各个分区的数据一致
- 可用性：部分分区故障，整体仍可用
- 分区容错性：分区间通信可能失败

### BASE

基本可用性，软状态和最终一致性，不符合 acid，啥也不保证

### 分库分表，读写分离

- 垂直划分：重新调整表结构，选择其中一些字段单独建表
- 水平划分：缩小表的大小

### mysql 数据类型
- varchar
- char

### 消息队列，使用场景

- 解耦：系统或进程间，通过消息队列进行交互
- 异步：对于一些不影响主流程的任务，可以异步来慢慢处理
- 消峰：避免系统垮掉造成请求丢失，相当于有一个数据缓冲，可以慢慢处理


### B vs B+

- B 树非叶子节点既有索引，又有数据，会使得节点距离跟节点的平均距离更近，适合查询单一记录，如mongodb。
- B+ 树非叶子节点不存储数据，只存储索引。叶节点通过链表连接，很容易遍历叶节点，利用缓存命中。适合范围查询。

### mysql 索引

- 主键索引：聚集索引。其他都是非聚集索引，叶节点存储主键，查询时如果没有覆盖索引，会有回表操作。
- 普通索引：对于组合索引，可以利用左前缀原则提升查询性能
- 唯一索引：类似于主键索引，列的值是唯一的，可以为空
- 全文索引：innodb支持全文索引。

### 全文索引与 ES

### 数据库索引分类以及特点

索引用于快速定位。
- hash：高查询效率；不适合区间查询；不适合磁盘；要考虑哈希冲突问题
- B 树：有效降低 io；适合磁盘存储
- B/B+：B+ 树中间的节点不存储数据，叶节点之间有指针相连，可以遍历。
- 聚集/非聚集：聚集索引在叶节点中存储记录，非聚集存储地址

### 事务中的 acid，隔离级别

- 原子性，一致性，隔离型，持久性
- 未提交读（能读到另一个事务未提交的数据），提交读（能读到另一个事务中提交的数据，有不可重复读问题），可重复度（mysql中默认，解决了不可重复读问题，但会有幻读问题），串行化（强制加锁，进行串行操作）
- 脏读（读到了另一个事务中未提交的数据），不可重复读（一个事务中，对特定记录相同的查询操作结果不同，是由于另一个事务对记录修改后提交导致），幻读（多次范围查询的结果不同，出现了别的事务中的新记录）
- mysql 中事务的实现方式：隔离性：行锁 + mvcc；持久性： redolog； 原子性：undolog

mvcc：

- 多版本并发控制，通过保存数据在某个时间点的快照来实现。在 innodb 中，使用隐藏的列保存事务版本号。
- 读操作不需要获得锁或者加锁，可以提高并发性；写操作也只会锁定特定的行。

### 数据库锁

- 乐观锁：不上锁，但提交时会检测错误。
- 悲观锁：每次都会上锁。
- 共享锁（读锁）：与共享锁兼容，可以多个读操作同时获得，阻塞写操作。
- 排他锁（写锁）：不与其他锁兼容，只能独占，阻塞读写操作。
- innodb中，使用的是行锁：
   - 可以锁定单个记录(record lock)或者一个范围内的多个记录(next-key lock)
   - 两阶段加锁。在事务执行的过程中，随时后可以加锁，在提交或者回滚时释放所有的锁。
   - 可以显式加锁，select ... for update, select ... lock in share mod


### redis 缓存穿透/雪崩/击穿


### redis 哨兵

- 哨兵检测每个节点：故障发现/转移和通知，监控主节点/从节点和其他哨兵节点。

### redis 集群

- redis 采用虚拟槽分区策略，数据分布在槽中，每个节点拥有多个槽。这样方便数据拆分及集群扩展。

### redis 高可用

- redis 的高可用可以通过集群和哨兵实现
- redis 数据丢失不能完全避免：异步复制；切换 master 节点，而服务器端没来得及切换，之前的 master 恢复后变成从节点，数据会清空

### 缓存的问题
- 数据一致：根据业务，需不需要强一致性，一定的过期时间；更新或删除数据时，清除缓存
- 


## 操作系统

### linux 命令

- netstat
- iostat
- top

### 调度算法，如何设计一个调度程序

- 先来先服务 FCFS
- 最短作业优先 SJF
- 高优先级优先调度
- 轮转时间片
- 多级反馈队列


### 操作系统内存管理机制

分页（多级+TLB）+交换

### unix 进程通信方式

- 管道：半双工，数据只能单向流动，一端读一端写；亲缘进程间，如父子，兄弟
- 命名管道：存在于文件系统。
- 消息队列：
- 信号量：实现进程间的互斥与同步。
- 共享内存：最快，与信号量一起使用，用于同步。
- socket：可以是远程。

### 线程与进程的区别

- 进程：运行中程序地抽象，包含寄存器/指令指针/堆栈
- 线程：可调度地最小单元，同一进程中的多个线程共享地址空间，每个线程有独的栈。多线程编程发展成一个成熟的编程范式。

### 线程与协程的区别

- 协程属于协作式多任务，由用户调度。语言级概念。并发。不需要线程中
- 线程属于抢占式多任务，由系统调度。系统级概念，需要操作系统和硬件支持。可以提供并行。

为什么要使用协程？基于事件驱动的并发中，基本实现是基于回调。但回调适合于简单的情形，会导致连续的逻辑分散在各个回调函数中，导致代码难以维护；同时异常处理也有问题：堆栈无法跟踪。采用协程可以更自然地编码，更好地异常处理和堆栈跟踪。

### 为什么要加锁，自旋锁，锁对性能的影响，死锁的原因

- 加锁为了竞争造成对临界区的错误修改
- 锁是一种虚拟的资源，会有内存和cpu开销。获取锁/释放锁开支。加锁还会影响并发。锁的粒度；其它方式替代锁。

死锁原因：互斥，不可剥夺，循环等待，请求和保持
预防：检测，避免死锁，接触死锁

### 分布式锁

- redis  

### malloc 算法

- 底层维护一个空闲链表
- 首次适应
- 最佳适应

## 综合

### 设计一个线程池

### 设计模式

- 单例模式
- 工厂模式：工厂方法模式，工厂

### 最有成就感的项目，最有难度的项目，如何解决

- 从 0 到 1 搭建一个完整的项目时，整个架构，前后端选型，代码结构，数据表设计，部署等

### 秒杀场景

CDN节点，限流，nginx 负载均衡，redis 预热，库存查询事务，MQ 削峰

### 如何重构

- 确定重构的目标：提高可读性；提高性能等
- 频繁测试
