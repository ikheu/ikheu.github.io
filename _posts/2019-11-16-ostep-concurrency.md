---
layout: post
title:  操作系统——并发
excerpt: ''
categories: 操作系统
tags: 并发
---

## 锁

并发编程的基本问题，是希望一系列的指令能以原子的方式执行。单核时，存在cpu中断，线程未执行完临界区，就切换别的线程执行；多核时，多个线程会同时执行临界区。这都会导致线程不安全。因此就发明了锁，保护临界区能像单条原子指令一样执行。多线程的调度由操作系统控制，操作系统会按照自身的调度逻辑切换线程而无视临界区问题。锁为我们提供了最小程度的调度控制，将操作系统这种混乱的调度状态变得可控。

锁的原理：
- 锁处于可用时，表示锁没有被线程持有，因此线程可以通过 `lock` 获得锁，进入临界区
- 锁处于占用时，表示锁已经有线程持有了，其他线程不能获得该锁，该锁的持有者可以调用 `unlock`，将锁变得可用。

简而言之，所提供了临界区的互斥，保证只有一个线程进入临界区。

锁的不同粒度策略：
- 粗粒度策略：任何临界区使用一个大锁
- 细粒度策略：lock 和 unlock 可以传入变量，因此可以用不同的锁保护不同的数据和结构，这样可以提高并发。

锁的评价标准：
- 互斥性：基本功能
- 公平性：不同线程获得锁的机会是否公平
- 性能：使用锁后增加的时间成本