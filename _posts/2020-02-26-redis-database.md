Redis 内置了多种数据结构，这些数据结构用于构建我们使用的数据对象，同时它们也在 Redis 内部使用。本文介绍简单介绍这些数据结构的设计原理。

## 字符串

用途：
-
-


## 字典

用途：
-
-


## 列表

用途：
-
-


## 跳跃表

用途：
-
-


## 整数集合

整数集合（intset）是用来保存整数的集合，支持多种宽度的整数类型，包括 int16_t, int32_t 和 int64_t。底层实现基于一个数组，在该数组中，整数有序排列且不重复。

```c
typedef struct intset {
    // 编码方式
    uint32_t encoding;
    // 元素数量
    uint32_t length;
    // 保存元素的数组
    int8_t contents[];
} intset;
```

注意到数组 contents 的类型为 int8_t，多个 int8_t 元素即可构成我们想要的 encoding 编码，如 int16_t 由两个相邻的 int8_t 构成。编码方式由在最大宽度的元素决定，当新插入的元素的宽度大于当前的编码方式时，整数集合会升级编码：将所有元素按照新的编码方式保存。数组的插入操作比较低效，只有在元素数量不太多时才会使用这种数据结构。

保存集合元素的数组具有如下特性：

- 动态扩展。
- 多种编码。根据元素大小，自动升级编码，支持多种整数类型。
- 有序。查找元素时使用二分法。

用途：
-
-


## 压缩列表

压缩列表（ziplist）是一种连续内存的数据结构，包含任意数量的节点，每个节点存储一个整数或一个字节数组。在前文中，整数集合的每个元素有统一的编码，这使得设计十分简单，但元素数量很多时可能会造成内存的浪费。压缩列表可以节约内存，这也意味着该数据结构的设计会更加复杂。

每个压缩列表节点由三部分组成：

- previous_entry_length 前一个节点的长度。视前一个节点长度的大小，该属性可能为 1 字节或多个字节。通过 previous_entry_length 可以反向遍历压缩列表。
- encoding 数据类型与长度。标识位记录编码，其余位记录 content 字节长度。可能为 1 字节或多字节长。
- content 节点值。类型与长度由 encoding 决定。

previous_entry_length 所占的字节数与前一个节点的长度有关。删除或新增节点可能造成下一个节点的 previous_entry_length 属性的长度发生变化，需要重新对其分配内存，继而可能形成多米诺骨牌效应，随后的多个节点都进行空间扩展，即发生`连锁更新`。连锁更新性能低下，但发生的条件苛刻：连续多个节点的长度处于即将引发 previous_entry_length 变化的范围内。

用途：
- 
- 