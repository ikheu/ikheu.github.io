---
layout: post
title:  Redis 中的数据结构
categories: 数据库
tags: Redis
---
* content
{:toc}

Redis 内置了多种数据结构，这些数据结构用于构建我们使用的数据对象，同时它们也在 Redis 内部使用。本文介绍简单介绍这些数据结构的设计原理。

## 字符串

C 字符串是不可修改的，而且获取字符串长度需要遍历整个字符串，只能用于一些简单的场景，如打印日志。Redis 使用简单的动态字符串 (simple dynamic string，SDS) 作为默认字符串的数据结构。一个 SDS 的结构如下：

```c
struct sdshdr {
    // buf 数组中已使用的字节数
    int len;
    // buf 数组中空闲的字节数
    int free;
    // 保存字符串值的数组
    char buf[];
}
```

buf 以字节进行存储，因此除了存储文本数据外，还可以用于存储图像等二进制数据。为了兼容 C 中的字符串 API，buf 遵循了以 \0 结尾。每次修改 buf 数组时都会记录最新的 len 属性，因此能以 O(1) 复杂度获取字符串长度，而不用遍历整个字符串。

SDS 的动态性体现在 buf 的动态伸缩上。在进行字符串增长操作时，预留的 free 字节数可能不够用，要重新进行内存分配，并且分配的空间不是刚好够用就行，而要比实际需要的大。在进行字符串缩短操作时，不会真正进行内存空间释放，而只更改 len 和 free 进行记录。buf 数组的这种伸缩策略，可以避免频繁内存分配造成的开销，提升修改字符串长度操作的性能。

用途：
1. 保存数据库的字符串值，可能是键或者值
2. 用作内部的缓冲区，如 AOF 持久化缓冲区，客户端输入缓冲区


## 链表

链表是一种基本的数据结构，它的每个节点存储了相邻节点的链接，因此可以进行高效的节点增删操作。据不同的实现，链表可能是单向的、双向的或者环形的等。Redis 中链表节点、链表的结构如下：

```c
typedef struct listNode {
    // 前置节点
    struct listNode * prev;
    // 后置节点
    struct listNode * next;
    // 节点的值
    void * value;
} listNode;
```

用途：
- 实现链表键
- 用于发布与订阅、慢查询、监视器等功能
- 保存客户端状态信息，客户端输出缓冲区

## 字典

用途：
- 
- 

## 跳跃表

用途：
-
-


## 整数集合

整数集合（intset）是用来保存整数的集合，支持多种宽度的整数类型，包括 int16_t, int32_t 和 int64_t。底层实现基于一个数组，在该数组中，整数有序排列且不重复。

```c
typedef struct intset {
    // 编码方式
    uint32_t encoding;
    // 元素数量
    uint32_t length;
    // 保存元素的数组
    int8_t contents[];
} intset;
```

注意到数组 contents 的类型为 int8_t，多个 int8_t 元素即可构成我们想要的 encoding 编码，如 int16_t 由两个相邻的 int8_t 构成。编码方式由在最大宽度的元素决定，当新插入的元素的宽度大于当前的编码方式时，整数集合会升级编码：将所有元素按照新的编码方式保存。数组的插入操作比较低效，只有在元素数量不太多时才会使用这种数据结构。

保存集合元素的数组具有如下特性：

- 动态扩展。
- 多种编码。根据元素大小，自动升级编码，支持多种整数类型。
- 有序。查找元素时使用二分法。

用途：
-
-


## 压缩列表

压缩列表（ziplist）是一种连续内存的数据结构，包含任意数量的节点，每个节点存储一个整数或一个字节数组。在前文中，整数集合的每个元素有统一的编码，这使得设计十分简单，但元素数量很多时可能会造成内存的浪费。压缩列表可以节约内存，这也意味着该数据结构的设计会更加复杂。

每个压缩列表节点由三部分组成：

- previous_entry_length 前一个节点的长度。视前一个节点长度的大小，该属性可能为 1 字节或多个字节。通过 previous_entry_length 可以反向遍历压缩列表。
- encoding 数据类型与长度。标识位记录编码，其余位记录 content 字节长度。可能为 1 字节或多字节长。
- content 节点值。类型与长度由 encoding 决定。

previous_entry_length 所占的字节数与前一个节点的长度有关。删除或新增节点可能造成下一个节点的 previous_entry_length 属性的长度发生变化，需要重新对其分配内存，继而可能形成多米诺骨牌效应，随后的多个节点都进行空间扩展，即发生`连锁更新`。连锁更新性能低下，但发生的条件苛刻：连续多个节点的长度处于即将引发 previous_entry_length 变化的范围内。

用途：
- 
- 

## 参考
1. [Redis 设计与实现](http://redisbook.com/)
2. [Redis内部数据结构详解](http://zhangtielei.com/posts/server.html)
3. [算法导论](https://book.douban.com/subject/20432061/)
