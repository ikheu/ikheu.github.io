---
layout: post
title: 操作系统——内存虚拟化
categories: 操作系统
tags: 内存
---

## 发展历史

早期的计算机更像一个厂房，既昂贵又占地方，还需要配有专门的操作员，很不友好。那时的操作系统还只是一些库，用户进程几乎独占内存。

后来开始有了小型机和个人计算机，人们对计算机要求的也不断提高，需要让计算机变得更易于使用，由此发展出了多道程序和时分共享。在多道程序中，多个进程被分配给计算机进行处理，操作系统会在一个进程休眠时切换到别的进程，这样可以有效利用计算机 CPU。时分共享强调了交互性，进程之间可以迅速切换，即使进程没有执行完毕或者休眠，这样多个用户就可以同时共享一台计算机，可以快速获得计算机的响应。

为了实现时分共享，一种粗糙的方式是让进程独占内存一小会，切换时保存到磁盘上。但这种方式效率太低了。为了更有效率地进行时分共享，需要给每个进程分配一部分内存。由于多个进程同时驻留在内存中，需要保护一个进程的内存不被其他进程读取或修改。

## 基本概念和虚拟化目标

地址空间是对物理内存的抽象，不同的进程有不同的物理内存进行隔离，但有相同的地址空间。地址空间向进程隐藏了物理细节，好像进程独占了内存空间。进程空间是内存虚拟化的关键，通过地址空间和真实物理内存间的映射关系，用户进程不需要直接访问物理内存。

进程的地址空间包含运行它所需要的所有状态，包括代码、静态区、堆和栈。代码即运行程序的指令。静态区保存初始化变量。栈负责保存函数调用信息，包括局部变量、函数参数和返回值。堆用于管理用户动态分配的内存。


虚拟内存的目标：

- 透明化。用户进程感知不到这种虚拟化，也无需为这种工作编写额外的代码，负责虚拟化的一切工作由操作系统和硬件在幕后完成。
- 效率。时空效率，不能太慢以及消耗太多额外的内存。
- 保护。进程之间相互隔离，不能进程不可以访问别的进程和操作系统的内存。

## 内存操作接口与空闲空间管理

在介绍时下内存虚拟化的机制之前，先了解一下操作系统提供的内存操作接口。

对于上文中地址空间的栈部分，通常由编译器来隐式管理，进行申请和释放。所以栈内存又被称为自动内存。我们更关注需要显式管理的内存，既堆内存。 操作系统提供了 `malloc` 和 `free` 两个系统调用，分别用于分配和释放内存。一些语言提供了垃圾回收机制，在自动申请内存，并在不再使用时自动释放。而使用 C 程序而言，需要自己来管理堆内存，因此需要注意以下问题：

- 没有正确地分配内存，包括不分配内存就使用、分配的内存不够用。
- 分配内存后使用不当。如没有填写值就去读取，导致读到一些未知的数据。
- 错误释放。忘记释放、过早释放、反复释放和错误释放了地址

`malloc` 和 `free` 是操作系统空闲空间管理模块提供的接口。底层会维护一个空闲列表，分配和释放意味着对这个列表进行分割和合并。分配内存时有一些分配策略：

- 最优匹配。找出适合的空闲块中最小的一个。性能代价高。
- 最差匹配。找出最大的一个。导致过量的碎片，性能代价高。
- 首次匹配。找到第一个足够大的。性能佳，碎片少。
- 下次匹配。类似于首次匹配，需要维护一个指针，指向上次查找结束的位置。
- 离空闲列表等。程序经常分配一下固定大小的内存，将这部分单独处理，其他部分使用通用的分配程序。
- 伙伴系统。以二分地方式进行分配与合并。分配的大小可能超出实际请求的大小，造成内部碎片。

## 地址转化

地址转化技术将虚拟的地址转化为实际的物理地址。地址转化依赖于硬件支持，以保证高效性。除此之外，操作系统需要在必要的时候介入，以管理整个内存。

我们假设用户的地址空间映射在物理内存上是连续的，地址空间小于物理内存，并且每个地址空间的大小是一样的。下面介绍地址转化首次在时分机器上的实践。

采用的方式是基址加界限机制，又称为动态重定位。CPU 中有一个负责地址转化的内存管理单元（MMU），包含两个寄存器：基址寄存器和限制寄存器。寄存器用来记录地址空间的起始物理地址，使用它可以将虚拟地址转化为物理地址。限制寄存器提供了访问保护，当前进程访问的地址超出这个界限时，CPU 将触发异常。

物理地址 = 基址 + 虚拟地址

动态重定位机制依赖于硬件和软件的支持。对于硬件：

- 特权模式
- 基址/界限寄存器
- 修改基址/界限寄存器的特权指令
- 虚拟地址转化以及检查是否越界
- 注册异常程序以及触发异常 

对于操作系统：

- 内存管理：启动时为进程分配内存空间，设置基址/界限寄存器；终止时回收空间；管理空闲列表。
- 基址/界限管理：上下文切换时，保存和恢复基址/界限寄存器。数据可能放在 PCB 中。PCB 位于内核中。
- 异常处理：操作系统向硬件提供异常处理程序，当进程越界发生时，CPU 触发异常，运行异常处理程序，操作系统终止进程并回收内存。

这种动态重定位技术存在空间浪费问题。进程的地址空间占有固定的槽块，而进程一开始可能用不了这么大，这会造成内部碎片。为了解决这个问题，引出了分段。

## 分段

上一节处理的方式中，堆与栈之间有一大块空闲区域，造成了内存的浪费。为了解决这个问题，引入了分段的概念。这时需要多个基址/界限寄存器，用来对应地址空间的每个逻辑段，这里仅分为三部分：代码/堆/栈。分段机制将不同的段分到不同的物理内存区域，避免了未使用部分对空间的浪费。


物理地址 = 段的基址 + 虚拟地址 - 段在地址空间内的偏移 = 段的基址 + 段内偏移

给定一个虚拟地址，如何知道它处于哪个段，以及段内偏移量是多少呢？

- 显式方法：因为有三个段，可以用虚拟地址的前两位表示段区域，其余位表示段内偏移。
- 隐式方法：硬件通过地址的产生方式来判断属于哪个段。

段寄存器除了记录基址和段大小外，还需要记录：

- 是否反向增长：栈和代码、堆不同，虚拟地址会反向增长，因此计算方式会有不同
- 保护：例如对于代码段，由于是可读的和可执行的，不同的进程会共享这个段。因此会有物理内存中的一个段被多个进程使用的情况。

上述所讲的段都是粗粒度的，也有一些早期系统使用更细粒度的段，来更高效地利用内存。更细粒度的段也需要硬件进一步地支持。

分段带来的问题：

- 每个段的数据都需要保存和恢复
- 每个段的大小可能不同，物理空间会存在许多空闲的小洞，因为不够大而无法非配给段，既出现外部碎片

如何应对分段造成的外部碎片呢？有以下方式：

- 紧凑物理内存。重排原来的段，同时要改变寄存器中的值，指向新的地址。但这种方式成本很高，需要占用大量 CPU 时间。
- 更好的空闲列表管理算法。有多种算法，可以试图降低外部碎片。


## 分页

分段将地址空间划分成不同长度的切片，这会造成外部碎片。另一种考虑是将地址空间划分为固定长度的分片，称之为分页。物理内存被划分为定长槽块，称之为页帧，每个页帧包含一个虚拟的内存页。

